
a user consists of

DROP KEYSPACE IF EXISTS users;
DROP KEYSPACE IF EXISTS wallets;
DROP KEYSPACE IF EXISTS transactions;
DROP KEYSPACE IF EXISTS programs;

CREATE KEYSPACE IF NOT EXISTS users
WITH REPLICATION = {'class' : 'SimpleStrategy','replication_factor' : 1};

CREATE TABLE IF NOT EXISTS users.user_by_user_id (
    userId text PRIMARY KEY,
    what other info about the user do i need to know here....
);

CREATE TABLE IF NOT EXISTS users.user_by_email (
    email text PRIMARY KEY,
    what other info about the user do i need to know here....
);

CREATE TABLE IF NOT EXISTS users.user_by_card_number (
    cardNumber text PRIMARY KEY,
    currentTier text,
    what other info about the user do i need to know here....
);



does the user exist in the system or not...


something like a summary transaction table by user and program id... maybe...?




WITH CLUSTERING ORDER BY (joined DESC) this is totally something we can do...


what about the program
what kind of querys do i actually need to support with it


//this is my main query....
so i have a card id... how do i know how many points i need to earn for that transaction

i have a user id and an amount of points i wish to use and i need to burn points in my purse

pointBook...? pointLedger...? what do i really wanna call it...?

what are the business rules that i need in order to actually determine if this is ok...

mycardtable
    cardNumber text,
    earnRate double

but how do i actually know what the earn rate is... really?...

but i have different earn rates per




{
  "type": "base",
  "pointBucket": "base",
  "earn": 1.0
},
{
  "type": "employee",
  "pointBucket": "base",
  "earn": 1.5
},
{
  "type": "employee",
  "pointBucket": "extra",
  "earn": 0.5
},
{
  "type": "chase",
  "pointBucket": "extra",
  "earn": 0.5
}









DROP KEYSPACE IF EXISTS wallets;
CREATE KEYSPACE IF NOT EXISTS wallets
WITH REPLICATION = {'class' : 'SimpleStrategy','replication_factor' : 1};

CREATE TABLE IF NOT EXISTS wallets.wallets (
    walletId text PRIMARY KEY,
    userId text,
    currentBillFold text,
    lifetimeBillFold text
);

DROP KEYSPACE IF EXISTS users;
CREATE KEYSPACE IF NOT EXISTS users
WITH REPLICATION = {'class' : 'SimpleStrategy','replication_factor' : 1};

CREATE TABLE IF NOT EXISTS users.ledger (
    email text PRIMARY KEY,
    userId text
);

CREATE TABLE IF NOT EXISTS users.users (
    userId text PRIMARY KEY,
    name text,
    email text
);

CREATE TABLE IF NOT EXISTS users.user_by_account (
    accountId text,
    date text,
    userId text,
    name text,
    PRIMARY KEY ((accountId),date,userId)
);

DROP KEYSPACE IF EXISTS accounts;
CREATE KEYSPACE IF NOT EXISTS accounts
WITH REPLICATION = {'class' : 'SimpleStrategy','replication_factor' : 1};

CREATE TABLE IF NOT EXISTS accounts.accounts (
    accountId text PRIMARY KEY,
    programId text,
    name text
);

CREATE TABLE IF NOT EXISTS accounts.account_by_user (
    userId text,
    date text,
    accountId text,
    name text,
    PRIMARY KEY ((userId),date,accountId)
);

DROP KEYSPACE IF EXISTS transactions;
CREATE KEYSPACE IF NOT EXISTS transactions
WITH REPLICATION = {'class' : 'SimpleStrategy','replication_factor' : 1};

CREATE TABLE IF NOT EXISTS transactions.transactions (
    userId text,
    date text,
    timestamp timeuuid,
    transactionId text,
    amountInBaseUnits int,
    currencyCode int,
    PRIMARY KEY((userId, date), timestamp)
);

CREATE TABLE IF NOT EXISTS transactions.ledger (
    userId text,
    transactionId text,
    PRIMARY KEY(userId, transactionId)
);

DROP KEYSPACE IF EXISTS programs;
CREATE KEYSPACE IF NOT EXISTS programs
WITH REPLICATION = {'class' : 'SimpleStrategy','replication_factor' : 1};

CREATE TABLE IF NOT EXISTS programs.programs (
    programId text,
    startDateTime text,
    endDateTime text,
    name text,
    tiers text,
    PRIMARY KEY((programId), startDateTime)
);


userId, programId,,


accountId, walletId, currentTier,

programId,



insert into users.users (userId,name,email) values ('111', 'bert', 'a@gmail.com');
insert into users.users (userId,name,email) values ('222', 'moose', 'b@gmail.com');
insert into users.users (userId,name,email) values ('333', 'llama', 'c@gmail.com');

insert into items.items (itemId,name,info) values ('aaa', 'Lamp', 'Lights up');
insert into items.items (itemId,name,info) values ('bbb', 'Chair', 'Ass holder');
insert into items.items (itemId,name,info) values ('ccc', 'Bed', 'zzzzzz');

insert into users.user_by_item (itemId,date,userId,name) values ('ccc', '2019-10-01', '111', 'Bed');
insert into users.user_by_item (itemId,date,userId,name) values ('ccc', '2019-10-01', '222', 'Bed');
insert into users.user_by_item (itemId,date,userId,name) values ('bbb', '2019-10-01', '111', 'Chair');
insert into users.user_by_item (itemId,date,userId,name) values ('bbb', '2019-10-01', '333', 'Chair');
insert into users.user_by_item (itemId,date,userId,name) values ('bbb', '2019-09-01', '333', 'Chair');
insert into users.user_by_item (itemId,date,userId,name) values ('bbb', '2020-09-01', '333', 'Chair');

so i have a user id
query to get the item id
query to get the item info

so i have an item id
query to get the userId
query to get the user info






from accountId get programId and current points/lifetime points and current tier and programInfo
from programId get program


i need my current points

if my models is going to be using the cluster parameters then low reads
if its just going to be using the primary keys then have at it hoss read away



account id <- currentTier currentPoints lifeTimePoints
program id <- amount to earn



